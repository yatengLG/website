import * as Type from './Type';

type MergeStrategy = (old: any, nu: any) => any;

const hasOwnProperty = Object.prototype.hasOwnProperty;

const shallow = function (old: Record<string, any>, nu: Record<string, any>) {
  return nu;
};

const deep = function (old: Record<string, any>, nu: Record<string, any>) {
  const bothObjects = Type.isObject(old) && Type.isObject(nu);
  return bothObjects ? deepMerge(old, nu) : nu;
};

const baseMerge = function (merger: MergeStrategy): (...objs: Array<Record<string, any>>) => any {
  return function () {
    // Don't use array slice(arguments), makes the whole function unoptimisable on Chrome
    const objects = new Array(arguments.length);
    for (let i = 0; i < objects.length; i++) {
      objects[i] = arguments[i];
    }

    if (objects.length === 0) {
      throw new Error('Can\'t merge zero objects');
    }

    const ret: Record<string, any> = {};
    for (let j = 0; j < objects.length; j++) {
      const curObject = objects[j];
      for (const key in curObject) {
        if (hasOwnProperty.call(curObject, key)) {
          ret[key] = merger(ret[key], curObject[key]);
        }
      }
    }
    return ret;
  };
};

export const deepMerge = baseMerge(deep);
export const merge = baseMerge(shallow);
